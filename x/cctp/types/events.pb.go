// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/cctp/v1/events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//
// Emitted when an attester is enabled
// @param attester newly enabled attester
type AttesterEnabled struct {
	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (m *AttesterEnabled) Reset()         { *m = AttesterEnabled{} }
func (m *AttesterEnabled) String() string { return proto.CompactTextString(m) }
func (*AttesterEnabled) ProtoMessage()    {}
func (*AttesterEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{0}
}
func (m *AttesterEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterEnabled.Merge(m, src)
}
func (m *AttesterEnabled) XXX_Size() int {
	return m.Size()
}
func (m *AttesterEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterEnabled proto.InternalMessageInfo

func (m *AttesterEnabled) GetAttester() string {
	if m != nil {
		return m.Attester
	}
	return ""
}

//
// Emitted when an attester is disabled
// @param attester newly disabled attester
type AttesterDisabled struct {
	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (m *AttesterDisabled) Reset()         { *m = AttesterDisabled{} }
func (m *AttesterDisabled) String() string { return proto.CompactTextString(m) }
func (*AttesterDisabled) ProtoMessage()    {}
func (*AttesterDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{1}
}
func (m *AttesterDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterDisabled.Merge(m, src)
}
func (m *AttesterDisabled) XXX_Size() int {
	return m.Size()
}
func (m *AttesterDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterDisabled proto.InternalMessageInfo

func (m *AttesterDisabled) GetAttester() string {
	if m != nil {
		return m.Attester
	}
	return ""
}

//
// Emitted when threshold number of attestations (m in m/n multisig) is updated
// @param old_signature_threshold old signature threshold
// @param new_signature_threshold new signature threshold
type SignatureThresholdUpdated struct {
	OldSignatureThreshold uint64 `protobuf:"varint,1,opt,name=old_signature_threshold,json=oldSignatureThreshold,proto3" json:"old_signature_threshold,omitempty"`
	NewSignatureThreshold uint64 `protobuf:"varint,2,opt,name=new_signature_threshold,json=newSignatureThreshold,proto3" json:"new_signature_threshold,omitempty"`
}

func (m *SignatureThresholdUpdated) Reset()         { *m = SignatureThresholdUpdated{} }
func (m *SignatureThresholdUpdated) String() string { return proto.CompactTextString(m) }
func (*SignatureThresholdUpdated) ProtoMessage()    {}
func (*SignatureThresholdUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{2}
}
func (m *SignatureThresholdUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureThresholdUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureThresholdUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureThresholdUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureThresholdUpdated.Merge(m, src)
}
func (m *SignatureThresholdUpdated) XXX_Size() int {
	return m.Size()
}
func (m *SignatureThresholdUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureThresholdUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureThresholdUpdated proto.InternalMessageInfo

func (m *SignatureThresholdUpdated) GetOldSignatureThreshold() uint64 {
	if m != nil {
		return m.OldSignatureThreshold
	}
	return 0
}

func (m *SignatureThresholdUpdated) GetNewSignatureThreshold() uint64 {
	if m != nil {
		return m.NewSignatureThreshold
	}
	return 0
}

//
// Emitted when authority address is updated
// @param previous_authority representing the address of the previous authority
// @param new_authority representing the address of the new authority
type AuthorityUpdated struct {
	PreviousAuthority string `protobuf:"bytes,1,opt,name=previous_authority,json=previousAuthority,proto3" json:"previous_authority,omitempty"`
	NewAuthority      string `protobuf:"bytes,2,opt,name=new_authority,json=newAuthority,proto3" json:"new_authority,omitempty"`
}

func (m *AuthorityUpdated) Reset()         { *m = AuthorityUpdated{} }
func (m *AuthorityUpdated) String() string { return proto.CompactTextString(m) }
func (*AuthorityUpdated) ProtoMessage()    {}
func (*AuthorityUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{3}
}
func (m *AuthorityUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorityUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorityUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorityUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorityUpdated.Merge(m, src)
}
func (m *AuthorityUpdated) XXX_Size() int {
	return m.Size()
}
func (m *AuthorityUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorityUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorityUpdated proto.InternalMessageInfo

func (m *AuthorityUpdated) GetPreviousAuthority() string {
	if m != nil {
		return m.PreviousAuthority
	}
	return ""
}

func (m *AuthorityUpdated) GetNewAuthority() string {
	if m != nil {
		return m.NewAuthority
	}
	return ""
}

//
// Emitted when burning and minting tokens is paused
type BurningAndMintingPausedEvent struct {
}

func (m *BurningAndMintingPausedEvent) Reset()         { *m = BurningAndMintingPausedEvent{} }
func (m *BurningAndMintingPausedEvent) String() string { return proto.CompactTextString(m) }
func (*BurningAndMintingPausedEvent) ProtoMessage()    {}
func (*BurningAndMintingPausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{4}
}
func (m *BurningAndMintingPausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurningAndMintingPausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurningAndMintingPausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurningAndMintingPausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurningAndMintingPausedEvent.Merge(m, src)
}
func (m *BurningAndMintingPausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *BurningAndMintingPausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_BurningAndMintingPausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_BurningAndMintingPausedEvent proto.InternalMessageInfo

//
// Emitted when burning and minting tokens is unpaused
type BurningAndMintingUnpausedEvent struct {
}

func (m *BurningAndMintingUnpausedEvent) Reset()         { *m = BurningAndMintingUnpausedEvent{} }
func (m *BurningAndMintingUnpausedEvent) String() string { return proto.CompactTextString(m) }
func (*BurningAndMintingUnpausedEvent) ProtoMessage()    {}
func (*BurningAndMintingUnpausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{5}
}
func (m *BurningAndMintingUnpausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurningAndMintingUnpausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurningAndMintingUnpausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurningAndMintingUnpausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurningAndMintingUnpausedEvent.Merge(m, src)
}
func (m *BurningAndMintingUnpausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *BurningAndMintingUnpausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_BurningAndMintingUnpausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_BurningAndMintingUnpausedEvent proto.InternalMessageInfo

//
// Emitted when sending and receiving messages is paused
type SendingAndReceivingPausedEvent struct {
}

func (m *SendingAndReceivingPausedEvent) Reset()         { *m = SendingAndReceivingPausedEvent{} }
func (m *SendingAndReceivingPausedEvent) String() string { return proto.CompactTextString(m) }
func (*SendingAndReceivingPausedEvent) ProtoMessage()    {}
func (*SendingAndReceivingPausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{6}
}
func (m *SendingAndReceivingPausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendingAndReceivingPausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendingAndReceivingPausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendingAndReceivingPausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendingAndReceivingPausedEvent.Merge(m, src)
}
func (m *SendingAndReceivingPausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SendingAndReceivingPausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SendingAndReceivingPausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SendingAndReceivingPausedEvent proto.InternalMessageInfo

//
// Emitted when sending and receiving messages is paused
type SendingAndReceivingUnpausedEvent struct {
}

func (m *SendingAndReceivingUnpausedEvent) Reset()         { *m = SendingAndReceivingUnpausedEvent{} }
func (m *SendingAndReceivingUnpausedEvent) String() string { return proto.CompactTextString(m) }
func (*SendingAndReceivingUnpausedEvent) ProtoMessage()    {}
func (*SendingAndReceivingUnpausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{7}
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendingAndReceivingUnpausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendingAndReceivingUnpausedEvent.Merge(m, src)
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SendingAndReceivingUnpausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SendingAndReceivingUnpausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SendingAndReceivingUnpausedEvent proto.InternalMessageInfo

//
// Emitted when a DepositForBurn message is sent
// @param nonce unique nonce reserved by message
// @param burn_token address of token burnt on source domain
// @param amount deposit amount
// @param depositor address where deposit is transferred from
// @param mint_recipient address receiving minted tokens on destination domain as bytes32
// @param destination_domain destination domain
// @param destination_token_messenger address of TokenMessenger on destination domain as bytes32
// @param destination_caller authorized caller as bytes32 of receiveMessage() on destination domain, if not equal to bytes32(0).
// If equal to bytes32(0), any address can call receiveMessage().
type DepositForBurn struct {
	Nonce                     uint64                `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	BurnToken                 string                `protobuf:"bytes,2,opt,name=burn_token,json=burnToken,proto3" json:"burn_token,omitempty"`
	Amount                    cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	Depositor                 string                `protobuf:"bytes,4,opt,name=depositor,proto3" json:"depositor,omitempty"`
	MintRecipient             []byte                `protobuf:"bytes,5,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	DestinationDomain         uint32                `protobuf:"varint,6,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	DestinationTokenMessenger []byte                `protobuf:"bytes,7,opt,name=destination_token_messenger,json=destinationTokenMessenger,proto3" json:"destination_token_messenger,omitempty"`
	DestinationCaller         []byte                `protobuf:"bytes,8,opt,name=destination_caller,json=destinationCaller,proto3" json:"destination_caller,omitempty"`
}

func (m *DepositForBurn) Reset()         { *m = DepositForBurn{} }
func (m *DepositForBurn) String() string { return proto.CompactTextString(m) }
func (*DepositForBurn) ProtoMessage()    {}
func (*DepositForBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{8}
}
func (m *DepositForBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositForBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositForBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositForBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositForBurn.Merge(m, src)
}
func (m *DepositForBurn) XXX_Size() int {
	return m.Size()
}
func (m *DepositForBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositForBurn.DiscardUnknown(m)
}

var xxx_messageInfo_DepositForBurn proto.InternalMessageInfo

func (m *DepositForBurn) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DepositForBurn) GetBurnToken() string {
	if m != nil {
		return m.BurnToken
	}
	return ""
}

func (m *DepositForBurn) GetDepositor() string {
	if m != nil {
		return m.Depositor
	}
	return ""
}

func (m *DepositForBurn) GetMintRecipient() []byte {
	if m != nil {
		return m.MintRecipient
	}
	return nil
}

func (m *DepositForBurn) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *DepositForBurn) GetDestinationTokenMessenger() []byte {
	if m != nil {
		return m.DestinationTokenMessenger
	}
	return nil
}

func (m *DepositForBurn) GetDestinationCaller() []byte {
	if m != nil {
		return m.DestinationCaller
	}
	return nil
}

//
// Emitted when tokens are minted
// @param mint_recipient recipient address of minted tokens
// @param amount amount of minted tokens
// @param mint_token contract address of minted token
type MintAndWithdraw struct {
	MintRecipient string                `protobuf:"bytes,1,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	Amount        cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	MintToken     string                `protobuf:"bytes,3,opt,name=mint_token,json=mintToken,proto3" json:"mint_token,omitempty"`
}

func (m *MintAndWithdraw) Reset()         { *m = MintAndWithdraw{} }
func (m *MintAndWithdraw) String() string { return proto.CompactTextString(m) }
func (*MintAndWithdraw) ProtoMessage()    {}
func (*MintAndWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{9}
}
func (m *MintAndWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintAndWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintAndWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintAndWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintAndWithdraw.Merge(m, src)
}
func (m *MintAndWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MintAndWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MintAndWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MintAndWithdraw proto.InternalMessageInfo

func (m *MintAndWithdraw) GetMintRecipient() string {
	if m != nil {
		return m.MintRecipient
	}
	return ""
}

func (m *MintAndWithdraw) GetMintToken() string {
	if m != nil {
		return m.MintToken
	}
	return ""
}

//
// Emitted when a token pair is linked
// @param local_token local token to support
// @param remote_domain remote domain
// @param remote_token token on `remoteDomain` corresponding to `localToken`
type TokenPairLinked struct {
	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  string `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (m *TokenPairLinked) Reset()         { *m = TokenPairLinked{} }
func (m *TokenPairLinked) String() string { return proto.CompactTextString(m) }
func (*TokenPairLinked) ProtoMessage()    {}
func (*TokenPairLinked) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{10}
}
func (m *TokenPairLinked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenPairLinked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenPairLinked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenPairLinked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPairLinked.Merge(m, src)
}
func (m *TokenPairLinked) XXX_Size() int {
	return m.Size()
}
func (m *TokenPairLinked) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPairLinked.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPairLinked proto.InternalMessageInfo

func (m *TokenPairLinked) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

func (m *TokenPairLinked) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *TokenPairLinked) GetRemoteToken() string {
	if m != nil {
		return m.RemoteToken
	}
	return ""
}

//
// Emitted when a token pair is unlinked
// @param local_token local token address
// @param remote_domain remote domain
// @param remote_token token on `remoteDomain` unlinked from `localToken`
type TokenPairUnlinked struct {
	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  string `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (m *TokenPairUnlinked) Reset()         { *m = TokenPairUnlinked{} }
func (m *TokenPairUnlinked) String() string { return proto.CompactTextString(m) }
func (*TokenPairUnlinked) ProtoMessage()    {}
func (*TokenPairUnlinked) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{11}
}
func (m *TokenPairUnlinked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenPairUnlinked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenPairUnlinked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenPairUnlinked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPairUnlinked.Merge(m, src)
}
func (m *TokenPairUnlinked) XXX_Size() int {
	return m.Size()
}
func (m *TokenPairUnlinked) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPairUnlinked.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPairUnlinked proto.InternalMessageInfo

func (m *TokenPairUnlinked) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

func (m *TokenPairUnlinked) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *TokenPairUnlinked) GetRemoteToken() string {
	if m != nil {
		return m.RemoteToken
	}
	return ""
}

//
// Emitted when a new message is dispatched
// @param message Raw bytes of message
type MessageSent struct {
	Message []byte `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *MessageSent) Reset()         { *m = MessageSent{} }
func (m *MessageSent) String() string { return proto.CompactTextString(m) }
func (*MessageSent) ProtoMessage()    {}
func (*MessageSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{12}
}
func (m *MessageSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageSent.Merge(m, src)
}
func (m *MessageSent) XXX_Size() int {
	return m.Size()
}
func (m *MessageSent) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageSent.DiscardUnknown(m)
}

var xxx_messageInfo_MessageSent proto.InternalMessageInfo

func (m *MessageSent) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

//
// Emitted when a new message is received
// @param caller caller (msg.sender) on destination domain
// @param source_domain the source domain this message originated from
// @param nonce the nonce unique to this message
// @param sender the sender of this message
// @param message_body message body bytes
type MessageReceived struct {
	Caller       string `protobuf:"bytes,1,opt,name=caller,proto3" json:"caller,omitempty"`
	SourceDomain uint32 `protobuf:"varint,2,opt,name=source_domain,json=sourceDomain,proto3" json:"source_domain,omitempty"`
	Nonce        uint64 `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Sender       []byte `protobuf:"bytes,4,opt,name=sender,proto3" json:"sender,omitempty"`
	MessageBody  []byte `protobuf:"bytes,5,opt,name=message_body,json=messageBody,proto3" json:"message_body,omitempty"`
}

func (m *MessageReceived) Reset()         { *m = MessageReceived{} }
func (m *MessageReceived) String() string { return proto.CompactTextString(m) }
func (*MessageReceived) ProtoMessage()    {}
func (*MessageReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{13}
}
func (m *MessageReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageReceived.Merge(m, src)
}
func (m *MessageReceived) XXX_Size() int {
	return m.Size()
}
func (m *MessageReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageReceived.DiscardUnknown(m)
}

var xxx_messageInfo_MessageReceived proto.InternalMessageInfo

func (m *MessageReceived) GetCaller() string {
	if m != nil {
		return m.Caller
	}
	return ""
}

func (m *MessageReceived) GetSourceDomain() uint32 {
	if m != nil {
		return m.SourceDomain
	}
	return 0
}

func (m *MessageReceived) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MessageReceived) GetSender() []byte {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MessageReceived) GetMessageBody() []byte {
	if m != nil {
		return m.MessageBody
	}
	return nil
}

//
// Emitted when max message body size is updated
// @param new_max_message_body_size new maximum message body size, in bytes
type MaxMessageBodySizeUpdated struct {
	NewMaxMessageBodySize uint64 `protobuf:"varint,1,opt,name=new_max_message_body_size,json=newMaxMessageBodySize,proto3" json:"new_max_message_body_size,omitempty"`
}

func (m *MaxMessageBodySizeUpdated) Reset()         { *m = MaxMessageBodySizeUpdated{} }
func (m *MaxMessageBodySizeUpdated) String() string { return proto.CompactTextString(m) }
func (*MaxMessageBodySizeUpdated) ProtoMessage()    {}
func (*MaxMessageBodySizeUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{14}
}
func (m *MaxMessageBodySizeUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxMessageBodySizeUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxMessageBodySizeUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxMessageBodySizeUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxMessageBodySizeUpdated.Merge(m, src)
}
func (m *MaxMessageBodySizeUpdated) XXX_Size() int {
	return m.Size()
}
func (m *MaxMessageBodySizeUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxMessageBodySizeUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_MaxMessageBodySizeUpdated proto.InternalMessageInfo

func (m *MaxMessageBodySizeUpdated) GetNewMaxMessageBodySize() uint64 {
	if m != nil {
		return m.NewMaxMessageBodySize
	}
	return 0
}

//
// Emitted when a remote TokenMessenger is added
// @param domain remote domain
// @param token_messenger TokenMessenger on remote domain
type RemoteTokenMessengerAdded struct {
	Domain         uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	TokenMessenger []byte `protobuf:"bytes,2,opt,name=token_messenger,json=tokenMessenger,proto3" json:"token_messenger,omitempty"`
}

func (m *RemoteTokenMessengerAdded) Reset()         { *m = RemoteTokenMessengerAdded{} }
func (m *RemoteTokenMessengerAdded) String() string { return proto.CompactTextString(m) }
func (*RemoteTokenMessengerAdded) ProtoMessage()    {}
func (*RemoteTokenMessengerAdded) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{15}
}
func (m *RemoteTokenMessengerAdded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteTokenMessengerAdded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteTokenMessengerAdded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteTokenMessengerAdded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteTokenMessengerAdded.Merge(m, src)
}
func (m *RemoteTokenMessengerAdded) XXX_Size() int {
	return m.Size()
}
func (m *RemoteTokenMessengerAdded) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteTokenMessengerAdded.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteTokenMessengerAdded proto.InternalMessageInfo

func (m *RemoteTokenMessengerAdded) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *RemoteTokenMessengerAdded) GetTokenMessenger() []byte {
	if m != nil {
		return m.TokenMessenger
	}
	return nil
}

//
// Emitted when a remote TokenMessenger is removed
// @param domain remote domain
// @param token_messenger TokenMessenger on remote domain
type RemoteTokenMessengerRemoved struct {
	Domain         uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	TokenMessenger []byte `protobuf:"bytes,2,opt,name=token_messenger,json=tokenMessenger,proto3" json:"token_messenger,omitempty"`
}

func (m *RemoteTokenMessengerRemoved) Reset()         { *m = RemoteTokenMessengerRemoved{} }
func (m *RemoteTokenMessengerRemoved) String() string { return proto.CompactTextString(m) }
func (*RemoteTokenMessengerRemoved) ProtoMessage()    {}
func (*RemoteTokenMessengerRemoved) Descriptor() ([]byte, []int) {
	return fileDescriptor_28d657a20514ec78, []int{16}
}
func (m *RemoteTokenMessengerRemoved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteTokenMessengerRemoved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteTokenMessengerRemoved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteTokenMessengerRemoved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteTokenMessengerRemoved.Merge(m, src)
}
func (m *RemoteTokenMessengerRemoved) XXX_Size() int {
	return m.Size()
}
func (m *RemoteTokenMessengerRemoved) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteTokenMessengerRemoved.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteTokenMessengerRemoved proto.InternalMessageInfo

func (m *RemoteTokenMessengerRemoved) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *RemoteTokenMessengerRemoved) GetTokenMessenger() []byte {
	if m != nil {
		return m.TokenMessenger
	}
	return nil
}

func init() {
	proto.RegisterType((*AttesterEnabled)(nil), "noble.cctp.v1.AttesterEnabled")
	proto.RegisterType((*AttesterDisabled)(nil), "noble.cctp.v1.AttesterDisabled")
	proto.RegisterType((*SignatureThresholdUpdated)(nil), "noble.cctp.v1.SignatureThresholdUpdated")
	proto.RegisterType((*AuthorityUpdated)(nil), "noble.cctp.v1.AuthorityUpdated")
	proto.RegisterType((*BurningAndMintingPausedEvent)(nil), "noble.cctp.v1.BurningAndMintingPausedEvent")
	proto.RegisterType((*BurningAndMintingUnpausedEvent)(nil), "noble.cctp.v1.BurningAndMintingUnpausedEvent")
	proto.RegisterType((*SendingAndReceivingPausedEvent)(nil), "noble.cctp.v1.SendingAndReceivingPausedEvent")
	proto.RegisterType((*SendingAndReceivingUnpausedEvent)(nil), "noble.cctp.v1.SendingAndReceivingUnpausedEvent")
	proto.RegisterType((*DepositForBurn)(nil), "noble.cctp.v1.DepositForBurn")
	proto.RegisterType((*MintAndWithdraw)(nil), "noble.cctp.v1.MintAndWithdraw")
	proto.RegisterType((*TokenPairLinked)(nil), "noble.cctp.v1.TokenPairLinked")
	proto.RegisterType((*TokenPairUnlinked)(nil), "noble.cctp.v1.TokenPairUnlinked")
	proto.RegisterType((*MessageSent)(nil), "noble.cctp.v1.MessageSent")
	proto.RegisterType((*MessageReceived)(nil), "noble.cctp.v1.MessageReceived")
	proto.RegisterType((*MaxMessageBodySizeUpdated)(nil), "noble.cctp.v1.MaxMessageBodySizeUpdated")
	proto.RegisterType((*RemoteTokenMessengerAdded)(nil), "noble.cctp.v1.RemoteTokenMessengerAdded")
	proto.RegisterType((*RemoteTokenMessengerRemoved)(nil), "noble.cctp.v1.RemoteTokenMessengerRemoved")
}

func init() { proto.RegisterFile("noble/cctp/v1/events.proto", fileDescriptor_28d657a20514ec78) }

var fileDescriptor_28d657a20514ec78 = []byte{
	// 844 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xdd, 0x6a, 0x1b, 0x47,
	0x14, 0xf6, 0xca, 0x89, 0x13, 0x1f, 0x4b, 0x76, 0xbc, 0x24, 0xa9, 0xe4, 0xc4, 0xb2, 0xba, 0xa1,
	0xc4, 0x37, 0x92, 0x08, 0xa5, 0xa5, 0x57, 0x05, 0xb9, 0x4e, 0xa0, 0x50, 0x43, 0x58, 0xc7, 0x14,
	0x4a, 0xe9, 0x76, 0xb4, 0x73, 0xba, 0x1a, 0xbc, 0x3b, 0xb3, 0xcc, 0xcc, 0xca, 0x3f, 0xf4, 0x0d,
	0x0a, 0xa5, 0x6f, 0xd0, 0xd7, 0xc9, 0x65, 0x2e, 0x4b, 0x2f, 0xd2, 0x62, 0xbf, 0x48, 0x99, 0x9f,
	0x95, 0x65, 0xd9, 0x50, 0x0a, 0x25, 0x77, 0x73, 0xbe, 0xf3, 0x9d, 0xff, 0x39, 0x33, 0xb0, 0xc5,
	0xc5, 0x38, 0xc7, 0x61, 0x9a, 0xea, 0x72, 0x38, 0x7d, 0x31, 0xc4, 0x29, 0x72, 0xad, 0x06, 0xa5,
	0x14, 0x5a, 0x84, 0x2d, 0xab, 0x1b, 0x18, 0xdd, 0x60, 0xfa, 0x62, 0xeb, 0x61, 0x26, 0x32, 0x61,
	0x35, 0x43, 0x73, 0x72, 0xa4, 0xa8, 0x0f, 0x1b, 0x23, 0xad, 0x51, 0x69, 0x94, 0x2f, 0x39, 0x19,
	0xe7, 0x48, 0xc3, 0x2d, 0xb8, 0x4f, 0x3c, 0xd4, 0x0e, 0x7a, 0xc1, 0xee, 0x6a, 0x3c, 0x93, 0xa3,
	0x01, 0x3c, 0xa8, 0xe9, 0xfb, 0x4c, 0xfd, 0x3b, 0xff, 0x97, 0x00, 0x3a, 0x87, 0x2c, 0xe3, 0x44,
	0x57, 0x12, 0xdf, 0x4c, 0x24, 0xaa, 0x89, 0xc8, 0xe9, 0x51, 0x49, 0x89, 0x46, 0x1a, 0x7e, 0x0e,
	0x1f, 0x89, 0x9c, 0x26, 0xaa, 0x26, 0x24, 0xba, 0x66, 0x58, 0x47, 0x77, 0xe2, 0x47, 0x22, 0xa7,
	0x37, 0xcd, 0x8d, 0x1d, 0xc7, 0x93, 0x5b, 0xed, 0x1a, 0xce, 0x8e, 0xe3, 0xc9, 0x4d, 0xbb, 0xe8,
	0x27, 0x78, 0x30, 0xaa, 0xf4, 0x44, 0x48, 0xa6, 0xcf, 0xea, 0x1c, 0xfa, 0x10, 0x96, 0x12, 0xa7,
	0x4c, 0x54, 0x2a, 0x21, 0xb5, 0xd2, 0xd7, 0xb1, 0x59, 0x6b, 0x66, 0x56, 0xe1, 0x33, 0x68, 0x99,
	0xd0, 0x57, 0xcc, 0x86, 0x65, 0x36, 0x39, 0x9e, 0xcc, 0x48, 0x51, 0x17, 0x9e, 0xee, 0x55, 0x92,
	0x33, 0x9e, 0x8d, 0x38, 0x3d, 0x60, 0x5c, 0x33, 0x9e, 0xbd, 0x26, 0x95, 0x42, 0xfa, 0xd2, 0x0c,
	0x28, 0xea, 0x41, 0xf7, 0x86, 0xfe, 0x88, 0x97, 0xd7, 0x19, 0x87, 0xc8, 0xa9, 0x63, 0xc4, 0x98,
	0x22, 0x9b, 0x2e, 0xf8, 0x88, 0xa0, 0x77, 0x0b, 0xe3, 0xba, 0x97, 0xbf, 0x1a, 0xb0, 0xbe, 0x8f,
	0xa5, 0x50, 0x4c, 0xbf, 0x12, 0xd2, 0x84, 0x0c, 0x1f, 0xc2, 0x5d, 0x2e, 0x78, 0x8a, 0xbe, 0xc1,
	0x4e, 0x08, 0xb7, 0x01, 0xc6, 0x95, 0xe4, 0x89, 0x16, 0xc7, 0xc8, 0x7d, 0x49, 0xab, 0x06, 0x79,
	0x63, 0x80, 0xf0, 0x33, 0x58, 0x21, 0x85, 0xa8, 0xb8, 0x6e, 0x2f, 0x1b, 0xd5, 0xde, 0xf6, 0xdb,
	0xf7, 0x3b, 0x4b, 0x7f, 0xbe, 0xdf, 0x79, 0x94, 0x0a, 0x55, 0x08, 0xa5, 0xe8, 0xf1, 0x80, 0x89,
	0x61, 0x41, 0xf4, 0x64, 0xf0, 0x35, 0xd7, 0xb1, 0x27, 0x87, 0x4f, 0x61, 0x95, 0xba, 0xe8, 0x42,
	0xb6, 0xef, 0x38, 0xa7, 0x33, 0x20, 0xfc, 0x04, 0xd6, 0x0b, 0xc6, 0x75, 0x22, 0x31, 0x65, 0x25,
	0x43, 0xae, 0xdb, 0x77, 0x7b, 0xc1, 0x6e, 0x33, 0x6e, 0x19, 0x34, 0xae, 0x41, 0x33, 0x1f, 0x8a,
	0x4a, 0x33, 0x4e, 0x34, 0x13, 0x3c, 0xa1, 0xa2, 0x20, 0x8c, 0xb7, 0x57, 0x7a, 0xc1, 0x6e, 0x2b,
	0xde, 0x9c, 0xd3, 0xec, 0x5b, 0x45, 0xf8, 0x25, 0x3c, 0x99, 0xa7, 0xdb, 0x82, 0x92, 0x02, 0x95,
	0x42, 0x9e, 0xa1, 0x6c, 0xdf, 0xb3, 0x21, 0x3a, 0x73, 0x14, 0x5b, 0xe1, 0x41, 0x4d, 0x58, 0x0c,
	0x97, 0x92, 0x3c, 0x47, 0xd9, 0xbe, 0x6f, 0xcd, 0xe6, 0xc3, 0x7d, 0x65, 0x15, 0xd1, 0xaf, 0x01,
	0x6c, 0x98, 0x01, 0x8e, 0x38, 0xfd, 0x96, 0xe9, 0x09, 0x95, 0xe4, 0xe4, 0x96, 0xc2, 0xdc, 0x6d,
	0x5a, 0x28, 0xec, 0xaa, 0xa9, 0x8d, 0xff, 0xd2, 0xd4, 0x6d, 0x00, 0xeb, 0xdd, 0x8d, 0x6a, 0xd9,
	0x75, 0xd5, 0x20, 0xb6, 0x90, 0xe8, 0x1c, 0x36, 0xec, 0xe1, 0x35, 0x61, 0xf2, 0x1b, 0xc6, 0x8f,
	0x91, 0x86, 0x3b, 0xb0, 0x96, 0x8b, 0x94, 0xe4, 0xde, 0xc4, 0x25, 0x03, 0x16, 0x72, 0xe3, 0x7d,
	0x06, 0x2d, 0x89, 0x85, 0xd0, 0x58, 0x77, 0xb7, 0x61, 0xbb, 0xdb, 0x74, 0xa0, 0x6f, 0xec, 0xc7,
	0xe0, 0xe5, 0x6b, 0x91, 0xd7, 0x1c, 0xe6, 0x62, 0xff, 0x0c, 0x9b, 0xb3, 0xd8, 0x47, 0x3c, 0xff,
	0xc0, 0xd1, 0x9f, 0xc3, 0x9a, 0x19, 0x23, 0xc9, 0xf0, 0xd0, 0xb4, 0xb7, 0x0d, 0xf7, 0x0a, 0x27,
	0xda, 0x98, 0xcd, 0xb8, 0x16, 0xa3, 0xdf, 0xcd, 0xcc, 0xdc, 0xd9, 0xed, 0x0d, 0xd2, 0xf0, 0x31,
	0xac, 0xf8, 0x51, 0xbb, 0x04, 0xbd, 0x64, 0x92, 0x53, 0xa2, 0x92, 0xe9, 0x62, 0x72, 0x0e, 0xf4,
	0xc9, 0xcd, 0x76, 0x6a, 0x79, 0x7e, 0xa7, 0x1e, 0xc3, 0x8a, 0x42, 0x4e, 0xd1, 0x5d, 0xfd, 0x66,
	0xec, 0x25, 0x53, 0x8a, 0xcf, 0x24, 0x19, 0x0b, 0x7a, 0xe6, 0x6f, 0xfd, 0x9a, 0xc7, 0xf6, 0x04,
	0x3d, 0x8b, 0x8e, 0xa0, 0x73, 0x40, 0x4e, 0x0f, 0xae, 0x90, 0x43, 0x76, 0x8e, 0xf5, 0x83, 0xf5,
	0x05, 0x74, 0xcc, 0x0b, 0x54, 0x90, 0xd3, 0x64, 0xde, 0x4f, 0xa2, 0xd8, 0x79, 0xbd, 0xd5, 0xe6,
	0xf9, 0xbb, 0xe9, 0x20, 0xfa, 0x1e, 0x3a, 0xf1, 0x55, 0xc3, 0x66, 0x77, 0x7e, 0x44, 0xa9, 0xeb,
	0x80, 0x2f, 0x31, 0xb0, 0x25, 0x7a, 0x29, 0x7c, 0x0e, 0x1b, 0x8b, 0x4b, 0xd4, 0xb0, 0x19, 0xaf,
	0xeb, 0x6b, 0x5e, 0xa2, 0x1f, 0xe0, 0xc9, 0x6d, 0xde, 0x0d, 0x36, 0xfd, 0x1f, 0xfc, 0xef, 0xfd,
	0xf8, 0xf6, 0xa2, 0x1b, 0xbc, 0xbb, 0xe8, 0x06, 0x7f, 0x5f, 0x74, 0x83, 0xdf, 0x2e, 0xbb, 0x4b,
	0xef, 0x2e, 0xbb, 0x4b, 0x7f, 0x5c, 0x76, 0x97, 0xbe, 0x7b, 0x95, 0x31, 0x3d, 0xa9, 0xc6, 0x83,
	0x54, 0x14, 0x43, 0xa5, 0x25, 0xe1, 0x19, 0xe6, 0x62, 0x8a, 0x7d, 0xf3, 0x06, 0x56, 0x12, 0xd5,
	0xd0, 0x7e, 0x84, 0x7d, 0xf3, 0x11, 0xf6, 0xa5, 0xa8, 0x34, 0xca, 0x7e, 0x29, 0xd9, 0x94, 0x68,
	0x1c, 0x9e, 0xba, 0xaf, 0x53, 0x9f, 0x95, 0xa8, 0xc6, 0x2b, 0xf6, 0x4b, 0xfc, 0xf4, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x88, 0x59, 0xc3, 0x8a, 0x55, 0x07, 0x00, 0x00,
}

func (m *AttesterEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attester) > 0 {
		i -= len(m.Attester)
		copy(dAtA[i:], m.Attester)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Attester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttesterDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attester) > 0 {
		i -= len(m.Attester)
		copy(dAtA[i:], m.Attester)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Attester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureThresholdUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureThresholdUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureThresholdUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewSignatureThreshold != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.NewSignatureThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.OldSignatureThreshold != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OldSignatureThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthorityUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorityUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorityUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAuthority) > 0 {
		i -= len(m.NewAuthority)
		copy(dAtA[i:], m.NewAuthority)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewAuthority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousAuthority) > 0 {
		i -= len(m.PreviousAuthority)
		copy(dAtA[i:], m.PreviousAuthority)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousAuthority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BurningAndMintingPausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurningAndMintingPausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurningAndMintingPausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BurningAndMintingUnpausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurningAndMintingUnpausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurningAndMintingUnpausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SendingAndReceivingPausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendingAndReceivingPausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendingAndReceivingPausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SendingAndReceivingUnpausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendingAndReceivingUnpausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendingAndReceivingUnpausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DepositForBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositForBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositForBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DestinationCaller) > 0 {
		i -= len(m.DestinationCaller)
		copy(dAtA[i:], m.DestinationCaller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationCaller)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DestinationTokenMessenger) > 0 {
		i -= len(m.DestinationTokenMessenger)
		copy(dAtA[i:], m.DestinationTokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationTokenMessenger)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BurnToken) > 0 {
		i -= len(m.BurnToken)
		copy(dAtA[i:], m.BurnToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BurnToken)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MintAndWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintAndWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintAndWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MintToken) > 0 {
		i -= len(m.MintToken)
		copy(dAtA[i:], m.MintToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintToken)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenPairLinked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenPairLinked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenPairLinked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenPairUnlinked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenPairUnlinked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenPairUnlinked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageBody) > 0 {
		i -= len(m.MessageBody)
		copy(dAtA[i:], m.MessageBody)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MessageBody)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SourceDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Caller) > 0 {
		i -= len(m.Caller)
		copy(dAtA[i:], m.Caller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Caller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaxMessageBodySizeUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxMessageBodySizeUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxMessageBodySizeUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewMaxMessageBodySize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.NewMaxMessageBodySize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteTokenMessengerAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteTokenMessengerAdded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteTokenMessengerAdded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenMessenger) > 0 {
		i -= len(m.TokenMessenger)
		copy(dAtA[i:], m.TokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TokenMessenger)))
		i--
		dAtA[i] = 0x12
	}
	if m.Domain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteTokenMessengerRemoved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteTokenMessengerRemoved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteTokenMessengerRemoved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenMessenger) > 0 {
		i -= len(m.TokenMessenger)
		copy(dAtA[i:], m.TokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TokenMessenger)))
		i--
		dAtA[i] = 0x12
	}
	if m.Domain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttesterEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attester)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AttesterDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attester)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *SignatureThresholdUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldSignatureThreshold != 0 {
		n += 1 + sovEvents(uint64(m.OldSignatureThreshold))
	}
	if m.NewSignatureThreshold != 0 {
		n += 1 + sovEvents(uint64(m.NewSignatureThreshold))
	}
	return n
}

func (m *AuthorityUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousAuthority)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewAuthority)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *BurningAndMintingPausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BurningAndMintingUnpausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SendingAndReceivingPausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SendingAndReceivingUnpausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DepositForBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	l = len(m.BurnToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovEvents(uint64(m.DestinationDomain))
	}
	l = len(m.DestinationTokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DestinationCaller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MintAndWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.MintToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TokenPairLinked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovEvents(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TokenPairUnlinked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovEvents(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MessageSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MessageReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.SourceDomain != 0 {
		n += 1 + sovEvents(uint64(m.SourceDomain))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MessageBody)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MaxMessageBodySizeUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewMaxMessageBodySize != 0 {
		n += 1 + sovEvents(uint64(m.NewMaxMessageBodySize))
	}
	return n
}

func (m *RemoteTokenMessengerAdded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovEvents(uint64(m.Domain))
	}
	l = len(m.TokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *RemoteTokenMessengerRemoved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovEvents(uint64(m.Domain))
	}
	l = len(m.TokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttesterEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttesterDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureThresholdUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureThresholdUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureThresholdUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldSignatureThreshold", wireType)
			}
			m.OldSignatureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldSignatureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSignatureThreshold", wireType)
			}
			m.NewSignatureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSignatureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorityUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorityUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorityUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurningAndMintingPausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurningAndMintingPausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurningAndMintingPausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurningAndMintingUnpausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurningAndMintingUnpausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurningAndMintingUnpausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendingAndReceivingPausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendingAndReceivingPausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendingAndReceivingPausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendingAndReceivingUnpausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendingAndReceivingUnpausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendingAndReceivingUnpausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositForBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositForBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositForBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = append(m.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
			if m.MintRecipient == nil {
				m.MintRecipient = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTokenMessenger = append(m.DestinationTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationTokenMessenger == nil {
				m.DestinationTokenMessenger = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCaller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCaller = append(m.DestinationCaller[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationCaller == nil {
				m.DestinationCaller = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintAndWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintAndWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintAndWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenPairLinked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenPairLinked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenPairLinked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenPairUnlinked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenPairUnlinked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenPairUnlinked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceDomain", wireType)
			}
			m.SourceDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageBody = append(m.MessageBody[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageBody == nil {
				m.MessageBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxMessageBodySizeUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxMessageBodySizeUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxMessageBodySizeUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMaxMessageBodySize", wireType)
			}
			m.NewMaxMessageBodySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewMaxMessageBodySize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteTokenMessengerAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteTokenMessengerAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteTokenMessengerAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMessenger = append(m.TokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.TokenMessenger == nil {
				m.TokenMessenger = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteTokenMessengerRemoved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteTokenMessengerRemoved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteTokenMessengerRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMessenger = append(m.TokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.TokenMessenger == nil {
				m.TokenMessenger = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
